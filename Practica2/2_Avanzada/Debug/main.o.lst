   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"main.c"
  21              	.Ltext0:
  22              		.file 1 "../main.c"
 2739              		.align	2
 2742              	RL:
 2743 0000 00000000 		.word	0
 2744 0004 05000000 		.word	5
 2745 0008 00000000 		.word	0
 2746 000c 00000000 		.word	0
 2747 0010 00000000 		.word	0
 2748              		.bss
 2749              		.align	2
 2750              	contBUT1:
 2751 0000 00000000 		.space	4
 2752              		.align	2
 2753              	contBUT2:
 2754 0004 00000000 		.space	4
 2755              		.text
 2756              		.align	2
 2757              		.global	setup
 2759              	setup:
 2760              	.LFB0:
   1:../main.c     **** #include <stdio.h>
   2:../main.c     **** #include "44b.h"
   3:../main.c     **** #include "button.h"
   4:../main.c     **** #include "leds.h"
   5:../main.c     **** #include "utils.h"
   6:../main.c     **** #include "D8Led.h"
   7:../main.c     **** #include "gpio.h"
   8:../main.c     **** 
   9:../main.c     **** #define LETRA_E 14
  10:../main.c     **** #define LETRA_C 12
  11:../main.c     **** 
  12:../main.c     **** struct RLstat {
  13:../main.c     **** 	int moving;
  14:../main.c     **** 	int speed;
  15:../main.c     **** 	int iter;
  16:../main.c     **** 	int direction;
  17:../main.c     **** 	int position;
  18:../main.c     **** };
  19:../main.c     **** 
  20:../main.c     **** static struct RLstat RL = {
  21:../main.c     **** 	.moving = 0,
  22:../main.c     **** 	.speed = 5,
  23:../main.c     **** 	.iter = 0,
  24:../main.c     **** 	.direction = 0,
  25:../main.c     **** 	.position = 0,
  26:../main.c     **** };
  27:../main.c     **** 
  28:../main.c     **** static int contBUT1 = 0;
  29:../main.c     **** static int contBUT2 = 0;
  30:../main.c     **** 
  31:../main.c     **** int setup(void)
  32:../main.c     **** {
 2761              		.loc 1 32 0
 2762              		.cfi_startproc
 2763              		@ Function supports interworking.
 2764              		@ args = 0, pretend = 0, frame = 0
 2765              		@ frame_needed = 1, uses_anonymous_args = 0
 2766 0000 0DC0A0E1 		mov	ip, sp
 2767              	.LCFI0:
 2768              		.cfi_def_cfa_register 12
 2769 0004 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2770 0008 04B04CE2 		sub	fp, ip, #4
 2771              		.cfi_offset 14, -8
 2772              		.cfi_offset 13, -12
 2773              		.cfi_offset 11, -16
 2774              	.LCFI1:
 2775              		.cfi_def_cfa 11, 4
  33:../main.c     **** 	leds_init();
 2776              		.loc 1 33 0
 2777 000c FEFFFFEB 		bl	leds_init
  34:../main.c     **** 	D8Led_init();
 2778              		.loc 1 34 0
 2779 0010 FEFFFFEB 		bl	D8Led_init
  35:../main.c     **** 	D8Led_segment(RL.position);
 2780              		.loc 1 35 0
 2781 0014 54309FE5 		ldr	r3, .L2
 2782 0018 103093E5 		ldr	r3, [r3, #16]
 2783 001c 0300A0E1 		mov	r0, r3
 2784 0020 FEFFFFEB 		bl	D8Led_segment
  36:../main.c     **** 
  37:../main.c     **** 	/* Port G: configuración para espera activa */
  38:../main.c     **** 
  39:../main.c     **** 	//COMPLETAR: utilizando el interfaz para el puerto G definido en gpio.h hay
  40:../main.c     **** 	//que configurar los pines 6 y 7 del puerto G como pines de entrada y
  41:../main.c     **** 	//activar las correspondientes resistencias de pull-up
  42:../main.c     **** 	
  43:../main.c     **** 	/*******************************************/
  44:../main.c     **** 	portG_conf(6, INPUT);
 2785              		.loc 1 44 0
 2786 0024 0600A0E3 		mov	r0, #6
 2787 0028 0010A0E3 		mov	r1, #0
 2788 002c FEFFFFEB 		bl	portG_conf
  45:../main.c     **** 	portG_conf(7, INPUT);
 2789              		.loc 1 45 0
 2790 0030 0700A0E3 		mov	r0, #7
 2791 0034 0010A0E3 		mov	r1, #0
 2792 0038 FEFFFFEB 		bl	portG_conf
  46:../main.c     **** 	portG_conf_pup(6, ENABLE);
 2793              		.loc 1 46 0
 2794 003c 0600A0E3 		mov	r0, #6
 2795 0040 0110A0E3 		mov	r1, #1
 2796 0044 FEFFFFEB 		bl	portG_conf_pup
  47:../main.c     **** 	portG_conf_pup(7, ENABLE);
 2797              		.loc 1 47 0
 2798 0048 0700A0E3 		mov	r0, #7
 2799 004c 0110A0E3 		mov	r1, #1
 2800 0050 FEFFFFEB 		bl	portG_conf_pup
  48:../main.c     **** 
  49:../main.c     **** 	Delay(0);
 2801              		.loc 1 49 0
 2802 0054 0000A0E3 		mov	r0, #0
 2803 0058 FEFFFFEB 		bl	Delay
  50:../main.c     **** 	return 0;
 2804              		.loc 1 50 0
 2805 005c 0030A0E3 		mov	r3, #0
  51:../main.c     **** }
 2806              		.loc 1 51 0
 2807 0060 0300A0E1 		mov	r0, r3
 2808 0064 0CD04BE2 		sub	sp, fp, #12
 2809 0068 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2810 006c 1EFF2FE1 		bx	lr
 2811              	.L3:
 2812              		.align	2
 2813              	.L2:
 2814 0070 00000000 		.word	RL
 2815              		.cfi_endproc
 2816              	.LFE0:
 2818              		.align	2
 2819              		.global	loop
 2821              	loop:
 2822              	.LFB1:
  52:../main.c     **** 
  53:../main.c     **** int loop(void)
  54:../main.c     **** {
 2823              		.loc 1 54 0
 2824              		.cfi_startproc
 2825              		@ Function supports interworking.
 2826              		@ args = 0, pretend = 0, frame = 8
 2827              		@ frame_needed = 1, uses_anonymous_args = 0
 2828 0074 0DC0A0E1 		mov	ip, sp
 2829              	.LCFI2:
 2830              		.cfi_def_cfa_register 12
 2831 0078 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2832 007c 04B04CE2 		sub	fp, ip, #4
 2833              		.cfi_offset 14, -8
 2834              		.cfi_offset 13, -12
 2835              		.cfi_offset 11, -16
 2836              	.LCFI3:
 2837              		.cfi_def_cfa 11, 4
 2838 0080 08D04DE2 		sub	sp, sp, #8
  55:../main.c     **** 	unsigned int buttons = read_button();
 2839              		.loc 1 55 0
 2840 0084 FEFFFFEB 		bl	read_button
 2841 0088 10000BE5 		str	r0, [fp, #-16]
  56:../main.c     **** 
  57:../main.c     **** 	if (buttons & BUT1) {
 2842              		.loc 1 57 0
 2843 008c 10301BE5 		ldr	r3, [fp, #-16]
 2844 0090 013003E2 		and	r3, r3, #1
 2845 0094 FF3003E2 		and	r3, r3, #255
 2846 0098 000053E3 		cmp	r3, #0
 2847 009c 1800000A 		beq	.L5
  58:../main.c     **** 		// COMPLETAR: utilizando la interfaz para los leds definida en leds.h
  59:../main.c     **** 		// hay que apagar ambos leds
  60:../main.c     **** 		// También hay que comutar la dirección del movimiento del led rotante
  61:../main.c     **** 		// representado por el campo direction de la variable RL
  62:../main.c     **** 		led1_off();
 2848              		.loc 1 62 0
 2849 00a0 FEFFFFEB 		bl	led1_off
  63:../main.c     **** 		led2_off();
 2850              		.loc 1 63 0
 2851 00a4 FEFFFFEB 		bl	led2_off
  64:../main.c     **** 
  65:../main.c     **** 		RL.direction = ~RL.direction;
 2852              		.loc 1 65 0
 2853 00a8 90319FE5 		ldr	r3, .L13
 2854 00ac 0C3093E5 		ldr	r3, [r3, #12]
 2855 00b0 0320E0E1 		mvn	r2, r3
 2856 00b4 84319FE5 		ldr	r3, .L13
 2857 00b8 0C2083E5 		str	r2, [r3, #12]
  66:../main.c     **** 
  67:../main.c     **** 		contBUT1++;
 2858              		.loc 1 67 0
 2859 00bc 80319FE5 		ldr	r3, .L13+4
 2860 00c0 003093E5 		ldr	r3, [r3, #0]
 2861 00c4 012083E2 		add	r2, r3, #1
 2862 00c8 74319FE5 		ldr	r3, .L13+4
 2863 00cc 002083E5 		str	r2, [r3, #0]
  68:../main.c     **** 
  69:../main.c     **** 		if(contBUT1%4 == 0){
 2864              		.loc 1 69 0
 2865 00d0 6C319FE5 		ldr	r3, .L13+4
 2866 00d4 003093E5 		ldr	r3, [r3, #0]
 2867 00d8 033003E2 		and	r3, r3, #3
 2868 00dc 000053E3 		cmp	r3, #0
 2869 00e0 0700001A 		bne	.L5
  70:../main.c     **** 			D8Led_digit(LETRA_E);
 2870              		.loc 1 70 0
 2871 00e4 0E00A0E3 		mov	r0, #14
 2872 00e8 FEFFFFEB 		bl	D8Led_digit
  71:../main.c     **** 			Delay(10000);
 2873              		.loc 1 71 0
 2874 00ec 54019FE5 		ldr	r0, .L13+8
 2875 00f0 FEFFFFEB 		bl	Delay
  72:../main.c     **** 			D8Led_digit(LETRA_C);
 2876              		.loc 1 72 0
 2877 00f4 0C00A0E3 		mov	r0, #12
 2878 00f8 FEFFFFEB 		bl	D8Led_digit
  73:../main.c     **** 			Delay(10000);
 2879              		.loc 1 73 0
 2880 00fc 44019FE5 		ldr	r0, .L13+8
 2881 0100 FEFFFFEB 		bl	Delay
 2882              	.L5:
  74:../main.c     **** 		}
  75:../main.c     **** 
  76:../main.c     **** 	}
  77:../main.c     **** 
  78:../main.c     **** 	if (buttons & BUT2) {
 2883              		.loc 1 78 0
 2884 0104 10301BE5 		ldr	r3, [fp, #-16]
 2885 0108 023003E2 		and	r3, r3, #2
 2886 010c 000053E3 		cmp	r3, #0
 2887 0110 1100000A 		beq	.L6
  79:../main.c     **** 		// COMPLETAR: utilizando la interfaz para los leds definida en leds.h
  80:../main.c     **** 		// Incrementar contador de pulsaciones. Si es par, conumtar led1. Si es impar, conmutar el led2.
  81:../main.c     **** 		// También hay que comutar el estado de movimiento del led rotante
  82:../main.c     **** 		// representado por el campo moving de la variable RL, y en caso de
  83:../main.c     **** 		// ponerlo en marcha debemos reiniciar el campo iter al valor del campo
  84:../main.c     **** 		// speed.
  85:../main.c     **** 
  86:../main.c     **** 		contBUT2++;
 2888              		.loc 1 86 0
 2889 0114 30319FE5 		ldr	r3, .L13+12
 2890 0118 003093E5 		ldr	r3, [r3, #0]
 2891 011c 012083E2 		add	r2, r3, #1
 2892 0120 24319FE5 		ldr	r3, .L13+12
 2893 0124 002083E5 		str	r2, [r3, #0]
  87:../main.c     **** 
  88:../main.c     **** 		if(contBUT2%2 == 0)
 2894              		.loc 1 88 0
 2895 0128 1C319FE5 		ldr	r3, .L13+12
 2896 012c 003093E5 		ldr	r3, [r3, #0]
 2897 0130 013003E2 		and	r3, r3, #1
 2898 0134 000053E3 		cmp	r3, #0
 2899 0138 0100001A 		bne	.L7
  89:../main.c     **** 			led1_switch();
 2900              		.loc 1 89 0
 2901 013c FEFFFFEB 		bl	led1_switch
 2902 0140 000000EA 		b	.L8
 2903              	.L7:
  90:../main.c     **** 		else
  91:../main.c     **** 			led2_switch();
 2904              		.loc 1 91 0
 2905 0144 FEFFFFEB 		bl	led2_switch
 2906              	.L8:
  92:../main.c     **** 
  93:../main.c     **** 		RL.moving = ~RL.moving;
 2907              		.loc 1 93 0
 2908 0148 F0309FE5 		ldr	r3, .L13
 2909 014c 003093E5 		ldr	r3, [r3, #0]
 2910 0150 0320E0E1 		mvn	r2, r3
 2911 0154 E4309FE5 		ldr	r3, .L13
 2912 0158 002083E5 		str	r2, [r3, #0]
 2913              	.L6:
  94:../main.c     **** 
  95:../main.c     **** 	}
  96:../main.c     **** 
  97:../main.c     **** 	if (RL.moving) {
 2914              		.loc 1 97 0
 2915 015c DC309FE5 		ldr	r3, .L13
 2916 0160 003093E5 		ldr	r3, [r3, #0]
 2917 0164 000053E3 		cmp	r3, #0
 2918 0168 2D00000A 		beq	.L9
  98:../main.c     **** 
  99:../main.c     **** 		if (RL.iter == 0) {
 2919              		.loc 1 99 0
 2920 016c CC309FE5 		ldr	r3, .L13
 2921 0170 083093E5 		ldr	r3, [r3, #8]
 2922 0174 000053E3 		cmp	r3, #0
 2923 0178 2400001A 		bne	.L10
 100:../main.c     **** 			// COMPLETAR: debemos hacer avanzar el led rotante una posición en
 101:../main.c     **** 			// la dirección indicada por el campo direction de la variable RL.
 102:../main.c     **** 			// La posición actual está representada en el campo position.
 103:../main.c     **** 			// Recordar que queremos un movimiento circular, representado por
 104:../main.c     **** 			// las 6 primeras posiciones en el array Segmentes del display de 8
 105:../main.c     **** 			// segmentos, por lo que position debe estar siempre entre 0 y 5.
 106:../main.c     **** 
 107:../main.c     **** 			if(RL.direction == 0) {
 2924              		.loc 1 107 0
 2925 017c BC309FE5 		ldr	r3, .L13
 2926 0180 0C3093E5 		ldr	r3, [r3, #12]
 2927 0184 000053E3 		cmp	r3, #0
 2928 0188 0C00001A 		bne	.L11
 108:../main.c     **** 				RL.position--;
 2929              		.loc 1 108 0
 2930 018c AC309FE5 		ldr	r3, .L13
 2931 0190 103093E5 		ldr	r3, [r3, #16]
 2932 0194 012043E2 		sub	r2, r3, #1
 2933 0198 A0309FE5 		ldr	r3, .L13
 2934 019c 102083E5 		str	r2, [r3, #16]
 109:../main.c     **** 
 110:../main.c     **** 				if(RL.position < 0)
 2935              		.loc 1 110 0
 2936 01a0 98309FE5 		ldr	r3, .L13
 2937 01a4 103093E5 		ldr	r3, [r3, #16]
 2938 01a8 000053E3 		cmp	r3, #0
 2939 01ac 0F0000AA 		bge	.L12
 111:../main.c     **** 					RL.position = 5;
 2940              		.loc 1 111 0
 2941 01b0 88309FE5 		ldr	r3, .L13
 2942 01b4 0520A0E3 		mov	r2, #5
 2943 01b8 102083E5 		str	r2, [r3, #16]
 2944 01bc 0B0000EA 		b	.L12
 2945              	.L11:
 112:../main.c     **** 			}
 113:../main.c     **** 			else {
 114:../main.c     **** 				RL.position++;
 2946              		.loc 1 114 0
 2947 01c0 78309FE5 		ldr	r3, .L13
 2948 01c4 103093E5 		ldr	r3, [r3, #16]
 2949 01c8 012083E2 		add	r2, r3, #1
 2950 01cc 6C309FE5 		ldr	r3, .L13
 2951 01d0 102083E5 		str	r2, [r3, #16]
 115:../main.c     **** 
 116:../main.c     **** 				if(RL.position > 5)
 2952              		.loc 1 116 0
 2953 01d4 64309FE5 		ldr	r3, .L13
 2954 01d8 103093E5 		ldr	r3, [r3, #16]
 2955 01dc 050053E3 		cmp	r3, #5
 2956 01e0 020000DA 		ble	.L12
 117:../main.c     **** 					RL.position = 0;
 2957              		.loc 1 117 0
 2958 01e4 54309FE5 		ldr	r3, .L13
 2959 01e8 0020A0E3 		mov	r2, #0
 2960 01ec 102083E5 		str	r2, [r3, #16]
 2961              	.L12:
 118:../main.c     **** 			}
 119:../main.c     **** 
 120:../main.c     **** 			D8Led_segment(RL.position);
 2962              		.loc 1 120 0
 2963 01f0 48309FE5 		ldr	r3, .L13
 2964 01f4 103093E5 		ldr	r3, [r3, #16]
 2965 01f8 0300A0E1 		mov	r0, r3
 2966 01fc FEFFFFEB 		bl	D8Led_segment
 121:../main.c     **** 			RL.iter = RL.speed;
 2967              		.loc 1 121 0
 2968 0200 38309FE5 		ldr	r3, .L13
 2969 0204 042093E5 		ldr	r2, [r3, #4]
 2970 0208 30309FE5 		ldr	r3, .L13
 2971 020c 082083E5 		str	r2, [r3, #8]
 2972              	.L10:
 122:../main.c     **** 
 123:../main.c     **** 		}
 124:../main.c     **** 		
 125:../main.c     **** 		RL.iter--;
 2973              		.loc 1 125 0
 2974 0210 28309FE5 		ldr	r3, .L13
 2975 0214 083093E5 		ldr	r3, [r3, #8]
 2976 0218 012043E2 		sub	r2, r3, #1
 2977 021c 1C309FE5 		ldr	r3, .L13
 2978 0220 082083E5 		str	r2, [r3, #8]
 2979              	.L9:
 126:../main.c     **** 	}
 127:../main.c     **** 
 128:../main.c     **** 	Delay(2000); // espera de 200ms para que el bucle se repita 5 veces por segundo
 2980              		.loc 1 128 0
 2981 0224 7D0EA0E3 		mov	r0, #2000
 2982 0228 FEFFFFEB 		bl	Delay
 129:../main.c     **** 	return 0;
 2983              		.loc 1 129 0
 2984 022c 0030A0E3 		mov	r3, #0
 130:../main.c     **** }
 2985              		.loc 1 130 0
 2986 0230 0300A0E1 		mov	r0, r3
 2987 0234 0CD04BE2 		sub	sp, fp, #12
 2988 0238 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2989 023c 1EFF2FE1 		bx	lr
 2990              	.L14:
 2991              		.align	2
 2992              	.L13:
 2993 0240 00000000 		.word	RL
 2994 0244 00000000 		.word	contBUT1
 2995 0248 10270000 		.word	10000
 2996 024c 04000000 		.word	contBUT2
 2997              		.cfi_endproc
 2998              	.LFE1:
 3000              		.align	2
 3001              		.global	main
 3003              	main:
 3004              	.LFB2:
 131:../main.c     **** 
 132:../main.c     **** 
 133:../main.c     **** int main(void) {
 3005              		.loc 1 133 0
 3006              		.cfi_startproc
 3007              		@ Function supports interworking.
 3008              		@ args = 0, pretend = 0, frame = 0
 3009              		@ frame_needed = 1, uses_anonymous_args = 0
 3010 0250 0DC0A0E1 		mov	ip, sp
 3011              	.LCFI4:
 3012              		.cfi_def_cfa_register 12
 3013 0254 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3014 0258 04B04CE2 		sub	fp, ip, #4
 3015              		.cfi_offset 14, -8
 3016              		.cfi_offset 13, -12
 3017              		.cfi_offset 11, -16
 3018              	.LCFI5:
 3019              		.cfi_def_cfa 11, 4
 134:../main.c     **** 
 135:../main.c     **** 	setup();
 3020              		.loc 1 135 0
 3021 025c FEFFFFEB 		bl	setup
 3022              	.L16:
 136:../main.c     **** 
 137:../main.c     **** 	while (1) {
 138:../main.c     **** 		loop();
 3023              		.loc 1 138 0 discriminator 1
 3024 0260 FEFFFFEB 		bl	loop
 139:../main.c     **** 	}
 3025              		.loc 1 139 0 discriminator 1
 3026 0264 FDFFFFEA 		b	.L16
 3027              		.cfi_endproc
 3028              	.LFE2:
 3030              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\USUARI~2\AppData\Local\Temp\ccrZoqVx.s:2739   .data:00000000 $d
C:\Users\USUARI~2\AppData\Local\Temp\ccrZoqVx.s:2742   .data:00000000 RL
C:\Users\USUARI~2\AppData\Local\Temp\ccrZoqVx.s:2749   .bss:00000000 $d
C:\Users\USUARI~2\AppData\Local\Temp\ccrZoqVx.s:2750   .bss:00000000 contBUT1
C:\Users\USUARI~2\AppData\Local\Temp\ccrZoqVx.s:2753   .bss:00000004 contBUT2
C:\Users\USUARI~2\AppData\Local\Temp\ccrZoqVx.s:2756   .text:00000000 $a
C:\Users\USUARI~2\AppData\Local\Temp\ccrZoqVx.s:2759   .text:00000000 setup
C:\Users\USUARI~2\AppData\Local\Temp\ccrZoqVx.s:2814   .text:00000070 $d
C:\Users\USUARI~2\AppData\Local\Temp\ccrZoqVx.s:2818   .text:00000074 $a
C:\Users\USUARI~2\AppData\Local\Temp\ccrZoqVx.s:2821   .text:00000074 loop
C:\Users\USUARI~2\AppData\Local\Temp\ccrZoqVx.s:2993   .text:00000240 $d
C:\Users\USUARI~2\AppData\Local\Temp\ccrZoqVx.s:3000   .text:00000250 $a
C:\Users\USUARI~2\AppData\Local\Temp\ccrZoqVx.s:3003   .text:00000250 main
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
leds_init
D8Led_init
D8Led_segment
portG_conf
portG_conf_pup
Delay
read_button
led1_off
led2_off
D8Led_digit
led1_switch
led2_switch
